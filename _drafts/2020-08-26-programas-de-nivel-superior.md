---
layout: post
title:  "C# 9.0 Registros"
date:   2020-10-23 09:10:55 +0000
categories: csharp
permalink: /:categories/:title:output_ext
---

En este articulo les explicaré que son los Récords o registros en C# 9 y para qué se utilizan. Los registros o records en inglés son datos inmutables que básicamente tienen un comportamiento como transporte de datos viniendo como a sustituir este uso de los objetos que tenemos conocidos como DTOs que básicamente no tienen comportamiento solamente traen las propiedades para para transportar datos.

Para usar esta característica necesitas una versión del .NET 5 que trae integrado el soporte a C# 9.0. Lo que hizo el equipo del lenguaje de programación C# aquí fue crear una nueva palabra clave para para declarar los records y esta palabra clave es `Record` anteriormente estaban manejando una sintaxis que decía `data class` que es similar a otros lenguajes que ya soportan los registros por ejemplo **Kotlin**, **Scala** y **Java 14** que también ya tiene una versión en pruebas de los récords.

nos dice que en este programa estoy utilizando la característica de ser igual programas de alto nivel que por ahí tenemos un vídeo que básicamente lo que hacen es eliminar la necesidad de tener el método main y bueno comenzaremos a declarar un espacio de nombres para que declara un récord y entonces dentro de este espacio de nombres que lo vamos a llamar registros vamos a declarar un récord que va a ser público les digo que es la palabra clave récord todavía y como más más posibilidades que te puedes registrar aquí como por ejemplo puede ser un récord puede ser parcial es parcial es decir que lo puedes dividir en varios archivos en este caso no lo vamos a mostrar porque sé como el cash el caso básico y vamos a llamarle empleado y le vamos a aquí ya tenemos que tener unas propiedades pero estas propiedades tienen que tener una característica particular que son las de usar el la nueva palabra clave que también se agregan si se mueve que se llama init lo que hace esta propiedad es esta para esta palabra clave es volver a esta propiedad de solo inicialización es decir que no la puedes modificar después de inicializar este objeto y vamos a crear otra propiedad que va a tener string y que se va a ser el nombre también esta propiedad tiene el límite entonces este ya es un objeto completo este que tiene de particular bueno esto tiene de particular que cuando tú tienes 22 instancias de un registro que tienen los mismos valores estos van a ser iguales independientemente de que apunten a otro objeto esto lo veremos en un momento más bueno aquí lo que es ya que tienes un registro que puedes hacer con él pues puedes declarar una variable normal como cual lo haces con cualquier otro tipo va a ser igual a new y lo que haces aquí es utilizarla en la inicialización de colecciones que éste lo que hacen es haití y especificar después una lista separada por comas de las propiedades que tiene el objeto y y aquí ya tenemos un empleado aquí nos hace falta declarar el espacio de nombres porque éste está en este espacio de nombres que es registros y ahora sí que lo tenemos bueno lo que podemos hacer es como cualquier con cualquier otra otra otro tipo de ensillar lo que puedes hacer es acceder a sus propiedades bueno aquí voy a declarar este espacio de nombre para evitar usar el sistema tiene lo que puedo decir ahora te voy a usar la cara csis que decís art 7 que es la de string interpolación o la interpolación de cadenas y con esto puedo leer las propiedades de este objeto entonces y aquí yo puedo ejecutar este programa con dos de ron y pues veremos que las las propiedades de este objeto cuando yo quiero cambiar estas estas propiedades del objeto por ejemplo suponiendo que quisiera cambiar el aire su posible que quisiera cambiar el aire y le voy a poner ahora el 2 pero aquí ya me da un problema me dice que no que no que no podemos decir con una propiedad de solo inicialización porque es desorganización inicialización esto es lo que vuelve a este objeto inmutable bueno entonces por suponiendo que yo quiero tener un empleado 2 que está basado en este mismo que llega otra persona que igual se llama pedro pero ahora le toca el ay dignos de 200 que lo que yo puedo hacer es le voy a decir que va a ser una copia de esta persona pero también agregaron estas expresiones que se llaman with lo que hace aquí es específica va a ser este una copia una copia de este objeto pero pero este bueno más bien éste no es persona sino es lo que va a hacer va a ser una copia de este registro pero después de antes de hacer la copia va a cambiarle este este valor cosas así así ya puedes modificar este objeto y el objeto que sería el que queda este sin sin cambios lo que pasa es que está esta técnica le llaman mod mutación no destructiva es decir que no destruyes en los valores que tiene este objeto sino que creas uno nuevo a partir de él pero con nuevos valores entonces este otra de las cosas que podemos hacer con los récords o que como desde las características que tienen yo voy a declarar un empleado 3 con los mismos valores y lo que voy a hacer lo que voy a hacer primero voy a voy a escribir voy a usar el método de la clase object que se llama reference y cuando que lo que va a hacer es comparar si la referencia de empleado y empleado 3 es la misma aquí claramente me va a decir que no porque hace en este hacen referencia a diferentes instancias entonces yo aquí lo que veo es que me dice que esto es falso no esto es lo que yo voy a hacer ahora es y mandar a llamar el sniper para imprimir y después lo que hago es empleado voy a llamar al método y walsh de la clase empleadores y se dan cuenta estos métodos que trae la de aquí el de equal get loud y get type los hereda de la clase objeto es hoy te veremos un poco de cómo funciona la herencia con los records entonces lo que voy a hacer es comparar contra contra el empleado 3 que tiene los mismos valores el empleado 3 o sea tienen los valores lo que pasa regularmente cuando haces esta este funcionamiento con una clase es que te dice que son que son diferentes porque son diferentes instancias y aquí lo que está haciendo es que el método de y cuál es lo que hace es calcularlo definirlo en base a los valores es decir yo tengo este empleado aunque es una instancia diferente tiene los mismos valores y por lo tanto es el mismo objeto este es el comportamiento por defaul de los records tú podrías cambiarlos y si así lo deseas y otra cosa que les decía es que los récords soportan herencia por ejemplo yo puedo tener este un récord adicional que se va a llamar entidad y aquí lo voy a poner comporta este propiedades que son comunes en este caso va a ser el aire y aquí lo voy a poner init esta propiedad hay tipos realmente ya no la necesito entonces porque ya la tiene el objeto entidad y lo que voy a hacer es que este récord el de desde esta lista y este otro récord es decir que estos soportan herencia como ven este código sigue funcionando lo que si no está permitido es que es que un récord heredé de una clase por ejemplo si yo tengo público class otra entidad por último nos interesa qué que tenga alguna propiedad sino veremos qué error muestra cuando tratas de heredar de otra entidad entonces y luego luego nos marcó un error si nosotros dice bueno los registros pueden solo heredar de the object que es decir la clase de las que todos los objetos en sí sabe de él o de otro registro es decir no está permitida la herencia entre entre clases y registros nosotros bueno compilamos la aplicación y aquí nos da el mismo error no esto ya lo corregimos y pues esto sería como una introducción breve a a los registros todavía y como mucha información pero todavía ahí todavía hay posibilidad de que cambie.

Si tú quieres ver cómo cómo evoluciona todo este tema de de sillar te recomiendo este post del diseñador principal del lenguaje y esté aquí como explica claramente y también la especificación que está dentro del hip hop y aquí empieza un poco más como más técnico o más como más para diseñadores del lenguaje pero es un poco más difícil pero si podrías darle una revisada y revisar qué otras características tienen y pues por este vídeo sería todo seguimos en contacto y hasta la próxima.
